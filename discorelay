#!/usr/bin/env python3
import socket, json, threading, requests, time

class Puppeteer:

    def __init__(self, ip, port, channel, relay):
        self.ip = ip
        self.port = port
        self.channel = channel
        self.users = {}
        self.puppet = self.add_puppeteer()

    def send(self, socket, message):
        socket.send(bytes(message, "utf-8"))
        time.sleep(0.2)

    def add_puppeteer(self, nick='puppet'):
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((self.ip, self.port))
        self.send(s, ("NICK %s\n" % nick))
        self.send(s, ("USER %s 0 * :%s\n" % (nick, nick)))
        self.send(s, ("JOIN %s\n" % self.channel))

        threading.Thread(target=self.attend, args=(nick, s)).start()
        return s

    def attend(self, user, socket):
        while 1:
            buff = socket.recv(1024)
            if not buff:
                socket.close()
                print("can't connect")
                return

            msg = buff.decode("utf-8").split(' ')
            sender = msg[0].split('!')[0][1:]
            print(msg[0]) # debug
            print('------------')
            print(msg[1])

            if msg[0] == "PING":
                self.send(socket, ("PONG %s\n" % msg[1]) )
                continue
            if msg[1] == "PRIVMSG" and sender not in self.users:
                if msg[2] == self.channel and user == "puppet":
                    parsed_msg = " ".join(msg[3:])[1:-2] # parse channel msg
                    print(parsed_msg) # debug
                    continue


def build_discord_url(content): return f"https://discord.com/api/{content}"
def build_webhook_url(id, token): return build_discord_url(f"webhooks/{id}/{token}")
def get_auth_header(token): return {"Authorization": f"Bot {token}"}

class Disco: # channel

    def __init__(self, token, channel_id, relay):
        self.token = token
        self.channel_id = channel_id
        self.relay = relay
        self.webhooks = {}
        threading.Thread(target=self.attend).start()

    def attend(self):
        while 1:
            r = requests.get(
                build_discord_url(f"channels/{self.channel_id}/messages"),
                headers=get_auth_header(self.token)
            )

            if r.status_code < 200 or r.status_code >= 300:
                raise Exception(f"Error {r.status_code}: {r.content}")

            messages = json.loads(r.content)
            print(messages) # debug

    def push_contents(self, name, msg):
        if name not in self.webhooks:
            self.get_webhook(name)
        r = requests.post(
            self.webhooks[name],
            data={"content": msg, "username": name}
        )

        if r.status_code < 200 or r.status_code >= 300:
            raise Exception(f"Error {r.status_code}: {r.content}")


    def get_webhook(self, name):
        r = requests.get(
            build_discord_url(f"channels/{self.channel_id}/webhooks"),
            headers=get_auth_header(self.token)
        )

        if r.status_code < 200 or r.status_code >= 300:
            raise Exception(f"Error {r.status_code}: {r.content}")

        webhooks = json.loads(r.content)
        for webhook in webhooks:
            if webhook["name"] == name:
                self.webhooks[name] = build_webhook_url(webhook["id"], webhook["token"])
                return

        # create a new webhook if none exists
        r = requests.post(
            build_discord_url(f"channels/{self.channel_id}/webhooks"),
            headers=get_auth_header(self.token),
            data=json.dumps({"name": name})
        )

        if r.status_code < 200 or r.status_code >= 300:
            raise Exception(f"Error {r.status_code}: {r.content}")

        webhook = json.loads(r.content)
        self.webhooks[name] = build_webhook_url(webhook["id"], webhook["token"])
